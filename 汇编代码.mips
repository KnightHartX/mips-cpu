# 所实现的全部指令包括：lw、sw、ori、beq、j、sll、or、xor、add、addi、andi
# 1.lw：取字。从主存读一个字送至通用寄存器rt。主存字地址的计算方法为：首先将offset符号扩展至32位，然后与rs寄存器的内容相加。
# 2.sw：把一个字的数据从寄存器存储到存储器中。
# 3.ori：一个寄存器中的内容与一个立即数相或。
# 4.beq：条件转移指令，当两个寄存器内容相等时转移发生。
# 5.j：无条件跳转指令。直接跳转到对应的地址。
# 6.sll：逻辑左移。
#     注:逻辑左移=算数左移，右边统一添0 
#        逻辑右移，左边统一添0 
#        算数右移，左边添加的数和符号有关
# 7.or：或运算，两个寄存器中的内容相或。
# 8.xor：异或运算。两个寄存器中内容相异或。
# 9.add：相加运算。两个寄存器中内容相加。
# 10.addi：将立即数imme符号扩展至32位，与通用寄存器rs中的32位整数相加，如果根据补码加法溢出判定规则，结果不溢出，则将该结果存至通用寄存器rt；如果结果溢出， 则产生整数溢出异常，rt的值不变。
# 11.andi：将立即数imme无符号扩展至32位（高16位补0），并与通用寄存器rs中的32位数按位做“与”运算，结果存至通用寄存器rt。

ori $t7, $zero, 0 # 0与0做或运算，结果自然是0。此时$t7=0
main: # 标识符：main
lw $t5, 0xfffb($zero) # $t5: 存储当前状态。即I/O State。之后会拿去进行分支指令。
ori $t6, $zero, 0	  # $t6=00。此处代表(reset | BD),即按下下键。
beq $t5, $t6, WAIT_OP # 当$t5=0，I/O State==0，说明按下了中间的按钮，进入子程序Wait OP
ori $t6, $zero, 1     # $t6=01。此处代表上键。
beq $t5, $t6, WAIT_GET_DATA # 若$t5=1，此时进入子程序 WAIT_GET_DATA。
ori $t6, $zero, 3	  # 11和00相与，$t6=11。此时代表左键。
beq $t5, $t6, WAIT_CAL_SHOW # 若$t5=$t6，则说明按下了左键，进入分支程序WAIT_CAL_SHOW。
j WAIT_OP # 跳转至WAIT_OP

WAIT_GET_DATA:
ori $t7, $zero, 1  # $t7=1
j	main # 跳转至main

WAIT_CAL_SHOW: 
ori $t7, $zero, 3 # $t7=11  
j	main # 跳转至main

WAIT_OP: # WAIT_OP时在等待操作。此时对比$t1的值而发生跳转
# $t7=00——》跳转至main
# $t7=01——》跳转至GET_DATA
# $t7=11——》跳转至CAL_SHOW:程序执行后半部分
ori $s1, $zero, 0
beq $t7, $s1, main   	
ori $s1, $zero, 1
beq $t7, $s1, GET_DATA  
ori $s1, $zero, 3
beq $t7, $s1, CAL_SHOW  
j	main

GET_DATA: # 获取数据
lw		$t1, 	0xfffe($zero)	# $t1存储拨码开关低八位.0000000011111111
lw 	    $t0, 	0xffff($zero) 	# $t0存储拨码开关高八位.0000000000000111
sll 	$t0, 	$t0, 	8       # $t0左移八位，因为下面$t1要和$t0合成一个有效位为11位的16位数
or 		$t1, 	$t1, 	$t0 	# $t1=$t1||$t0。或运算，与0或运算的结果均为本身。
ori 	$t7, 	$zero, 	0       # $t7=00。证明GET_DATA这一阶段已经完成。
# 举例，若输入十一位2进制数11111111111，则此时
# $t0的值为16位数0000011100000000
# $t1的值为16位数0000011111111111
j	main                        # 跳转至main

CAL_SHOW:
xor		$t0,	$t0,	$t0	  # $t0与自己异或，得到的值存到$t0，故此时$t0的值为16b'0
add		$t0,	$t1,	$zero # $t0=$t1=0000011111111111	
xor		$t1,	$t1,	$t1	  #	$t1=0
addi	$t1,	$zero,	0x400 # $t1=0x400,即0000010000000000	
and		$t1,	$t0,	$t1	  # $t1&&$t0。得到：$t1=0000010000000000
beq		$t1,	$zero,	NOFST # 当$t1=0时，跳转至NOFST
xor		$t2,	$t2,	$t2	  # t2=0	
addi	$t2,	$zero,	0x1000# t2=0001000000000000

NOFST:							
xor		$t1,	$t1,	$t1	  # $t1清0	
addi	$t1,	$zero,	0x380 # $t1=0000001110000000
and		$t1,	$t0,	$t1   # $t1和$t0相与，$t1=0000001110000000
sll		$t1,	$t1,	0x1	  # t1左移一位。0000011100000000	
or		$t2,	$t1,	$t2	  # t2=t1||t2。0001011100000000
xor		$t1,	$t1,	$t1	  # t1=000000000000	
addi	$t1,	$zero,	0x7f  # t1=0000000001111111	
and		$t1,	$t0,	$t1   # t1=t0&&t1.t1=0000000001111111
or		$t1,	$t1,	$t2	  # t1=t1||t2.t1=0001011101111111
# 生成c1

xor		$t2,	$t2,	$t2	  # t2=0000000000000000
addi	$s1,	$zero,	0x400 # s1=0000010000000000
and		$t2,	$t0,	$s1	  # t2=t0&&s1.0000010000000000	
sll		$t3,	$t2,	0x3	  # t3=t2左移3位.0010000000000000	
sll		$t4,	$t3,	0x1	  # t4=t3左移1位.0100000000000000 	
or		$t3,	$t3,	$t4	  # t3=t3||t4.0110000000000000	
xor		$t1,	$t1,	$t3	  # t1=t1^t3.0001011101111111^0110000000000000=0111011101111111
addi	$s1,	$zero,	0x200 # s1=0000001000000000
and		$t2,	$t0,	$s1	  # t2=t0&&s1.0000001000000000	
sll		$t3,	$t2,	0x2	  # t3=t2左移2位.0000100000000000	
sll		$t4,	$t3,	0x3	  # t4=t3左移3位.0100000000000000	
or		$t3,	$t3,	$t4	  # t3=t3||t4.0100100000000000	
xor		$t1,	$t1,	$t3	  # t1=t1^t3.0011111101111111
# 0100100000000000	   
# 0111011101111111
# 生成c2，c4，c8类似

xor		$t1,	$t1,	$t3		#c1,c2,c4,c8更新;t1=t1^t3.0111111111111111


sw		$t1, 	0xfffc($zero)	#LED显示;输出t1

ori $t7, $zero, 0 # 清零$t7，跳至main
j	main
